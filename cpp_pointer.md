# C++ 문법 커리큘럼: 포인터와 레퍼런스

## 목차 (Table of Contents)

### 1. 포인터(Pointer)
1.1 포인터의 개념  
1.2 포인터에 타입이 필요한 이유  
1.3 포인터의 연산자  
1.4 상수 포인터(const pointer)  
1.5 포인터의 사용  
  - 1.5.1 변수로써의 사용  
  - 1.5.2 함수의 인자로써의 사용  
  - 1.5.3 함수 포인터  
1.6 포인터와 배열의 차이점(Decay)  
1.7 포인터 사용 시 주의할 점  
1.8 추가 학습 아이디어 (함수 포인터 vs std::function, 스마트 포인터, RAII 등)  

### 2. 레퍼런스(Reference)
2.1 레퍼런스 개념  
2.2 레퍼런스 타입이 필요한 이유  
2.3 포인터와 레퍼런스의 차이점  
2.4 레퍼런스의 규칙  
2.5 레퍼런스 사용 시 주의할 점  

### 3. 실습 및 예시 코드
3.1 포인터/레퍼런스 기초 예제  
3.2 swap 함수 예제 (포인터 vs 레퍼런스)  
3.3 배열/포인터, 함수 포인터 콜백 예시  
3.4 스마트 포인터 예제 (unique_ptr, shared_ptr)  

### 4. 마무리 및 요약

---

## 1. 포인터(Pointer)

### 1.1 포인터의 개념
**정의:** 포인터는 메모리 상의 주소(address)를 저장하는 변수이다.  
**장점:** 메모리에 직접 접근할 수 있어 동적 메모리 할당, 배열 처리, 함수 호출 시 원본 데이터 수정 등의 활용이 가능하다.  

### 1.2 포인터에 타입이 필요한 이유
포인터가 가리키는 대상을 정확히 해석하기 위해 해당 타입 정보가 필요하다.  
예) `int* p`와 `double* p`는 `p + 1` 연산 시 차이가 발생한다(4바이트 vs 8바이트).  
함수나 연산에 따라 올바른 메모리 크기 및 해석을 보장하기 위해 필요하다.  

### 1.3 포인터의 연산자
**주소 연산자 (`&`)**: 변수의 주소를 구한다.

```cpp
int a = 10;
int* p = &a; // p는 a의 주소를 가리킴
```

**간접 참조 연산자 (`*`)**: 포인터가 가리키는 값을 참조(접근)한다.

```cpp
*p = 20; // a의 값이 20으로 변경됨
```

**포인터 산술 연산**: `p + i`, `p - i`, `p++` 등은 타입 크기만큼 이동한다.  

### 1.4 상수 포인터 (const pointer)

```cpp
const int* p;      // 값 변경 불가, 주소 변경 가능
int* const p;      // 주소 변경 불가, 값 변경 가능
const int* const p; // 둘 다 변경 불가
```

### 1.5 포인터의 사용

#### 1.5.1 변수로써의 사용 (동적 메모리 할당)

```cpp
int* p = new int(10);
delete p; // 사용 후 메모리 해제
```

#### 1.5.2 함수의 인자로써의 사용

```cpp
void update(int* ptr) {
    *ptr = 20;
}
int main() {
    int a = 10;
    update(&a);  // a의 값이 20으로 변경됨
}
```

#### 1.5.3 함수 포인터

```cpp
int add(int x, int y) { return x + y; }
int main() {
    int (*funcPtr)(int, int) = &add;
    int result = funcPtr(2, 3); // 결과: 5
}
```

---

## 4. 마무리 및 요약
C++에서는 포인터와 레퍼런스를 이해하는 것이 중요하며, 현대 C++에서는 스마트 포인터 및 RAII를 적극 활용하는 것이 좋다.
